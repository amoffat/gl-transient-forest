import * as asc from "assemblyscript/asc";
import { Transform } from "assemblyscript/transform";
import fs from "fs/promises";
import { resolve } from "path";
import binaryen from "types:assemblyscript/lib/binaryen";
import { ViteDevServer } from "vite";

// These are the artifacts that will be generated by the compilation process.
// We'll write some of them to disk, and we'll send the WebAssembly binary to
// the client directly.
interface BuildArtifacts {
  // The WebAssembly binary
  wasm: Uint8Array;
  // The typescript definition file
  dts: string;
  // The javascript shim
  js: string;
}

// This embeds some get lost metadata into the wasm, for example, the get lost
// framework version, so that we know what framework to load before we execute
// the module.
class GLMetaAdder extends Transform {
  constructor(private meta: Record<string, string> = {}) {
    super();
  }
  afterCompile(module: binaryen.Module): void {
    const metaBuffer = new TextEncoder().encode(JSON.stringify(this.meta));
    module.addCustomSection("glmeta", metaBuffer);
  }
}

interface CompileError {
  message: string;
}

function isCompileError(e: unknown): e is CompileError {
  return e !== undefined && (e as CompileError).message !== undefined;
}

const repoDir = process.cwd();
const asmLibDir = resolve(repoDir, "assemblyscript");
const shimDir = asmLibDir;
const codeDir = resolve(repoDir, "level", "code");

async function compile(
  engineVersion: string,
  sourceFiles: string[]
): Promise<BuildArtifacts> {
  const outputFilePath = "main.wasm";

  const commandLineOptions = [
    ...sourceFiles,
    "--outFile",
    outputFilePath,
    "--target",
    "release",
    "--bindings",
    "raw",
    "--exportRuntime",
    "--path",
    asmLibDir,
  ];
  const artifacts: Partial<BuildArtifacts> = {};

  const stderr = asc.createMemoryStream();

  // Compile AssemblyScript programmatically
  const { error } = await asc.main(commandLineOptions, {
    stdout: process.stdout,
    stderr: stderr,
    transforms: [new GLMetaAdder({ engineVersion })],

    // Here we intercept the writeFile function to capture the artifacts without
    // writing them. We'll write them to disk ourselves later.
    writeFile: (fileName, contents) => {
      // The extension of the file
      const extension = fileName.split(".").pop();
      switch (extension) {
        case "wasm":
          // Save the WebAssembly binary
          artifacts.wasm = contents as Uint8Array;
          break;
        case "ts":
          // Save the TypeScript definition file
          artifacts.dts = contents as string;
          break;
        case "js":
          // Save the JavaScript shim
          artifacts.js = contents as string;
          break;
        default:
          throw new Error(`Unknown file extension: ${extension}`);
      }
    },
  });

  if (error) {
    throw { message: stderr.toString() };
  } else {
    return artifacts as BuildArtifacts;
  }
}

// Dynamically compile the AssemblyScript files as they are fetched.
export default function compileWasmPlugin() {
  return {
    name: "wasm-compiler",
    configureServer(server: ViteDevServer) {
      server.middlewares.use(async (req, res, next) => {
        const engineVersion = await fs.readFile(
          resolve(process.cwd(), "engine_version.txt"),
          "utf-8"
        );
        const url = req.url!;

        const match = url.match(/^\/main.wasm$/);
        if (match) {
          try {
            const levelFile = resolve(codeDir, "main.ts");
            const artifacts = await compile(engineVersion, [levelFile]);

            const defsFile = resolve(shimDir, "main.d.ts");
            const jsFile = resolve(shimDir, "main.js");

            // Check if the current definitions file is different from the new one
            const currentDefs = await fs
              .readFile(defsFile, "utf-8")
              .catch(() => "");
            if (currentDefs !== artifacts.dts) {
              await fs.writeFile(defsFile, artifacts.dts);
            }

            // Check if the current JS shim is different from the new one
            const currentJs = await fs
              .readFile(jsFile, "utf-8")
              .catch(() => "");
            if (currentJs !== artifacts.js) {
              await fs.writeFile(jsFile, artifacts.js);
            }

            res.setHeader("Content-Type", "application/wasm");
            res.statusCode = 200;

            res.end(artifacts.wasm);
          } catch (e) {
            if (isCompileError(e)) {
              server.ws.send("gl:wasm-compilation-error", e.message);
              console.error(e.message);
            } else {
              console.error(e);
            }
            res.writeHead(500, {
              "Content-Type": "text/plain",
              "Access-Control-Allow-Origin": "*",
            });
            res.end("Failed to compile");
            return;
          }
        } else {
          next();
        }
      });
    },
  };
}
