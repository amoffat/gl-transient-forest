import * as asc from "assemblyscript/asc";
import { Transform } from "assemblyscript/transform";
import { exec } from "child_process";
import { readFileSync } from "fs";
import fs from "fs/promises";
import { resolve } from "path";
import binaryen from "types:assemblyscript/lib/binaryen";
import util from "util";
import { ViteDevServer } from "vite";
import { sharedState } from "./shared";

// These are the artifacts that will be generated by the compilation process.
// We'll write some of them to disk, and we'll send the WebAssembly binary to
// the client directly.
interface BuildArtifacts {
  // The WebAssembly binary
  wasm: Uint8Array;
  // The typescript definition file
  dts: string;
  // The javascript shim
  js: string;
}

// This embeds some get lost metadata into the wasm, for example, the get lost
// framework version, so that we know what framework to load before we execute
// the module.
class GLMetaAdder extends Transform {
  constructor(private meta: Record<string, string> = {}) {
    super();
  }
  afterCompile(module: binaryen.Module): void {
    const metaBuffer = new TextEncoder().encode(JSON.stringify(this.meta));
    module.addCustomSection("glmeta", metaBuffer);
  }
}

interface CompileError {
  message: string;
}

function isCompileError(e: unknown): e is CompileError {
  return e !== undefined && (e as CompileError).message !== undefined;
}

const repoDir = process.cwd();
const asmLibDir = resolve(repoDir, "assemblyscript");
const shimDir = asmLibDir;
const levelDir = resolve(repoDir, "level");
const codeDir = resolve(repoDir, "level", "code");
let cachedWasm: Uint8Array = new Uint8Array(0);

const execAsync = util.promisify(exec);

const packageJson = JSON.parse(
  readFileSync(resolve(repoDir, "package.json"), "utf-8")
);
const tmplVersion = packageJson.version;

async function compile(
  engineVersion: string,
  sourceFiles: string[]
): Promise<BuildArtifacts> {
  const outputFilePath = "main.wasm";

  // Run the spindler command and write its output to dialogue.ts
  const spindlerInput = resolve(levelDir, "story", "Level.twee");
  const spindlerOutput = resolve(codeDir, "dialogue.ts");
  try {
    const { stdout } = await execAsync(`spindler ${spindlerInput}`);
    await fs.writeFile(spindlerOutput, stdout);
  } catch (error) {
    throw new Error(`Dialogue generation failed: ${error}`);
  }

  const commandLineOptions = [
    ...sourceFiles,
    "--outFile",
    outputFilePath,
    "--target",
    "release",
    "--bindings",
    "raw",
    "--exportRuntime",
    "--path",
    asmLibDir,
  ];
  const artifacts: Partial<BuildArtifacts> = {};

  const stderr = asc.createMemoryStream();

  // Compile AssemblyScript programmatically
  const { error } = await asc.main(commandLineOptions, {
    stdout: process.stdout,
    stderr: stderr,
    transforms: [new GLMetaAdder({ engineVersion, tmplVersion })],

    // Here we intercept the writeFile function to capture the artifacts without
    // writing them. We'll write them to disk ourselves later.
    writeFile: (fileName, contents) => {
      // The extension of the file
      const extension = fileName.split(".").pop();
      switch (extension) {
        case "wasm":
          // Save the WebAssembly binary
          artifacts.wasm = contents as Uint8Array;
          break;
        case "ts":
          // Save the TypeScript definition file
          artifacts.dts = contents as string;
          break;
        case "js":
          // Save the JavaScript shim
          artifacts.js = contents as string;
          break;
        default:
          throw new Error(`Unknown file extension: ${extension}`);
      }
    },
  });

  if (error) {
    throw { message: stderr.toString() };
  } else {
    return artifacts as BuildArtifacts;
  }
}

// Dynamically compile the AssemblyScript files as they are fetched.
export default function compileWasmPlugin() {
  return {
    name: "wasm-compiler",
    configureServer(server: ViteDevServer) {
      server.middlewares.use(async (req, res, next) => {
        const engineVersion = await fs.readFile(
          resolve(process.cwd(), "engine_version.txt"),
          "utf-8"
        );
        const url = req.url!;

        const match = url.match(/^\/main.wasm$/);
        if (match) {
          if (!sharedState.assemblyscriptTainted) {
            server.ws.send("gl:wasm-compiler", {
              msg: "Serving cached WASM",
              className: "success",
            });

            res.setHeader("Content-Type", "application/wasm");
            res.statusCode = 200;
            res.end(cachedWasm);
            return;
          }

          const start = performance.now();
          server.ws.send("gl:wasm-compiler", {
            msg: "Compiling WASM...",
            className: "success",
          });

          try {
            const levelFile = resolve(codeDir, "main.ts");
            const artifacts = await compile(engineVersion, [levelFile]);

            const defsFile = resolve(shimDir, "main.d.ts");
            const jsFile = resolve(shimDir, "main.js");

            // Check if the current definitions file is different from the new one
            const currentDefs = await fs
              .readFile(defsFile, "utf-8")
              .catch(() => "");
            if (currentDefs !== artifacts.dts) {
              await fs.writeFile(defsFile, artifacts.dts);
            }

            // Check if the current JS shim is different from the new one
            const currentJs = await fs
              .readFile(jsFile, "utf-8")
              .catch(() => "");
            if (currentJs !== artifacts.js) {
              await fs.writeFile(jsFile, artifacts.js);
            }

            res.setHeader("Content-Type", "application/wasm");
            res.statusCode = 200;
            res.end(artifacts.wasm);

            cachedWasm = artifacts.wasm;
            const end = performance.now();
            const time = (end - start).toFixed(2);
            server.ws.send("gl:wasm-compiler", {
              msg: `WASM compiled in ${time}ms`,
              className: "success",
            });
            sharedState.assemblyscriptTainted = false;
          } catch (e) {
            if (isCompileError(e)) {
              server.ws.send("gl:wasm-compiler", {
                msg: e.message,
                className: "error",
              });
              console.error(e.message);
            } else {
              console.error(e);
            }
            res.writeHead(500, {
              "Content-Type": "text/plain",
              "Access-Control-Allow-Origin": "*",
            });
            res.end("Failed to compile");
            return;
          }
        } else {
          next();
        }
      });
    },
  };
}
